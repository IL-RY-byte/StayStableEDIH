<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR Cerebellum Training</title>
    
    <!-- A-Frame -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/aframe/1.4.2/aframe.min.js"></script>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- A-Frame Extras -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/aframe-extras/7.3.0/aframe-extras.min.js"></script>
    
    <!-- A-Frame Physics -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/aframe-physics-system/4.0.1/aframe-physics-system.min.js"></script>
    
    <!-- Stats.js for performance monitoring -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r17/Stats.min.js"></script>
    
    <!-- Howler.js for audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #000;
            color: white;
            overflow: hidden;
        }

        #ui-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .panel {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff88;
            border-radius: 15px;
            padding: 20px;
            margin: 20px;
            backdrop-filter: blur(10px);
        }

        .stats-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
        }

        .control-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 300px;
        }

        .progress-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 250px;
        }

        .vr-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            text-align: center;
        }

        h1, h2, h3 {
            color: #00ff88;
            margin-bottom: 15px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 8px 0;
            border-bottom: 1px solid rgba(0, 255, 136, 0.3);
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00ccff);
            transition: width 0.3s ease;
        }

        button {
            background: linear-gradient(135deg, #00ff88, #00ccff);
            border: none;
            color: black;
            padding: 12px 24px;
            margin: 5px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            pointer-events: auto;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 136, 0.4);
        }

        .vr-button {
            background: linear-gradient(135deg, #ff0088, #ff00cc);
            color: white;
            font-size: 18px;
            padding: 15px 30px;
        }

        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            pointer-events: none;
            z-index: 999;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: #00ff88;
            border-radius: 2px;
        }

        .crosshair::before {
            width: 4px;
            height: 20px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .crosshair::after {
            width: 20px;
            height: 4px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff88;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            display: none;
            z-index: 1001;
            pointer-events: auto;
        }

        .training-complete {
            border-color: #ff0088;
        }

        #performance-stats {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
        }

        /* Hide UI in VR mode */
        body.vr-mode .panel,
        body.vr-mode .crosshair {
            display: none;
        }

        /* Performance warning */
        .performance-warning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: #ff4444;
            color: white;
            text-align: center;
            padding: 10px;
            display: none;
            z-index: 1002;
        }
    </style>
</head>
<body>
    <div id="ui-container">
        <div class="panel stats-panel">
            <h2>Training Stats</h2>
            <div class="stat-item">
                <span>Score:</span>
                <span id="score">0</span>
            </div>
            <div class="stat-item">
                <span>Targets Hit:</span>
                <span id="targets-hit">0</span>
            </div>
            <div class="stat-item">
                <span>Accuracy:</span>
                <span id="accuracy">0%</span>
            </div>
            <div class="stat-item">
                <span>Session Time:</span>
                <span id="session-time">00:00</span>
            </div>
            <div class="stat-item">
                <span>Learning Rate:</span>
                <span id="learning-rate">0%</span>
            </div>
        </div>

        <div class="panel control-panel">
            <h3>Training Mode</h3>
            <button onclick="changeMode('basic')">Basic Tracking</button>
            <button onclick="changeMode('advanced')">Advanced Patterns</button>
            <button onclick="changeMode('challenge')">Challenge Mode</button>
            <div style="margin-top: 15px;">
                <button onclick="startTraining()" id="start-btn">Start Training</button>
                <button onclick="resetTraining()">Reset</button>
            </div>
        </div>

        <div class="panel progress-panel">
            <h3>Progress</h3>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
            </div>
            <div class="stat-item">
                <span>Level:</span>
                <span id="level">1</span>
            </div>
            <div class="stat-item">
                <span>Next Level:</span>
                <span id="next-level">50 points</span>
            </div>
        </div>

        <div class="vr-controls">
            <button class="vr-button" onclick="toggleVR()">ENTER VR</button>
        </div>

        <div class="crosshair"></div>

        <div class="notification" id="notification">
            <h2 id="notification-title">Great Job!</h2>
            <p id="notification-message">You're making excellent progress!</p>
            <button onclick="hideNotification()">Continue</button>
        </div>

        <div class="performance-warning" id="performance-warning">
            Performance warning: Consider closing other applications for better VR experience
        </div>

        <div id="performance-stats"></div>
    </div>

    <!-- A-Frame Scene -->
    <a-scene 
        physics="debug: false; gravity: 0 -1.6 0"
        vr-mode-ui="enabled: true"
        device-orientation-permission-ui="enabled: true"
        background="color: #000011"
        stats
        renderer="antialias: true; colorManagement: true"
    >
        <!-- Assets -->
        <a-assets>
            <audio id="hit-sound" src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js" preload="auto"></audio>
            <audio id="success-sound" src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js" preload="auto"></audio>
            
            <!-- Sphere materials -->
            <a-mixin id="red-sphere" material="color: #FF4444; shader: standard; metalness: 0.3; roughness: 0.4"></a-mixin>
            <a-mixin id="blue-sphere" material="color: #4444FF; shader: standard; metalness: 0.3; roughness: 0.4"></a-mixin>
            <a-mixin id="green-sphere" material="color: #44FF44; shader: standard; metalness: 0.3; roughness: 0.4"></a-mixin>
        </a-assets>

        <!-- Camera with gaze-based cursor -->
        <a-entity id="rig" movement-controls="fly: true; speed: 0.5">
            <a-entity 
                camera="fov: 80; near: 0.01; far: 100" 
                position="0 1.6 0"
                look-controls="pointerLockEnabled: true"
                wasd-controls="enabled: false"
            >
                <a-entity 
                    cursor="fuse: true; fuseTimeout: 500"
                    position="0 0 -1"
                    geometry="primitive: ring; radiusInner: 0.008; radiusOuter: 0.012"
                    material="color: #00FF88; shader: flat"
                    animation__click="property: scale; startEvents: click; from: 0.1 0.1 0.1; to: 1 1 1; dur: 150"
                    animation__fusing="property: scale; startEvents: fusing; from: 1 1 1; to: 0.1 0.1 0.1; dur: 1500"
                    animation__mouseleave="property: scale; startEvents: mouseleave; to: 1 1 1; dur: 500"
                >
                </a-entity>
                
                <!-- Laser controls for VR -->
                <a-entity 
                    laser-controls="hand: right" 
                    raycaster="objects: .clickable; far: 20"
                    line="color: #00FF88; opacity: 0.5"
                ></a-entity>
            </a-entity>
        </a-entity>

        <!-- Environment -->
        <a-entity environment="preset: starry; groundColor: #001122; grid: cross"></a-entity>
        
        <!-- Lighting -->
        <a-entity light="type: ambient; color: #444; intensity: 0.4"></a-entity>
        <a-entity light="type: directional; color: #FFF; intensity: 0.8; position: 5 10 5" shadow="cast: true"></a-entity>
        <a-entity light="type: point; color: #00FF88; intensity: 0.3; position: 0 3 0" animation="property: intensity; to: 0.6; dir: alternate; dur: 2000; loop: true"></a-entity>

        <!-- Target Spawn Area -->
        <a-entity id="target-container"></a-entity>

        <!-- Visual Effects -->
        <a-entity id="effects-container"></a-entity>

        <!-- Floor -->
        <a-plane 
            position="0 0 0" 
            rotation="-90 0 0" 
            width="50" 
            height="50" 
            color="#112233"
            shadow="receive: true"
        ></a-plane>

        <!-- Sky -->
        <a-sky color="#000022"></a-sky>
    </a-scene>

    <script>
        // Training Configuration
        const TRAINING_MODES = {
            basic: {
                sphereCount: 5,
                spawnRate: 2000,
                sphereSpeed: 0.5,
                patterns: false,
                points: 10
            },
            advanced: {
                sphereCount: 8,
                spawnRate: 1500,
                sphereSpeed: 0.8,
                patterns: true,
                points: 15
            },
            challenge: {
                sphereCount: 12,
                spawnRate: 1000,
                sphereSpeed: 1.2,
                patterns: true,
                points: 20
            }
        };

        // Game State
        const gameState = {
            score: 0,
            targetsHit: 0,
            totalTargets: 0,
            accuracy: 0,
            sessionTime: 0,
            learningRate: 0,
            currentMode: 'basic',
            isTraining: false,
            level: 1,
            levelThreshold: 50,
            activeSpheres: [],
            sessionStartTime: 0,
            isVRMode: false
        };

        // Audio Manager
        const audioManager = {
            init() {
                this.hitSound = new Howl({
                    src: ['data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA=='],
                    volume: 0.3
                });
                
                this.successSound = new Howl({
                    src: ['data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA=='],
                    volume: 0.5
                });
            },
            
            playHit() {
                this.hitSound.play();
            },
            
            playSuccess() {
                this.successSound.play();
            }
        };

        // Sphere Manager
        const sphereManager = {
            container: document.querySelector('#target-container'),
            effects: document.querySelector('#effects-container'),
            
            createSphere(position = null) {
                const sphere = document.createElement('a-entity');
                
                if (!position) {
                    position = this.getRandomPosition();
                }
                
                sphere.setAttribute('position', position);
                sphere.setAttribute('geometry', { primitive: 'sphere', radius: 0.3 });
                sphere.setAttribute('class', 'clickable');
                sphere.setAttribute('animation', {
                    property: 'rotation',
                    to: '0 360 0',
                    dur: 2000,
                    loop: true,
                    easing: 'linear'
                });
                
                // Add glowing effect
                sphere.setAttribute('light', {
                    type: 'point',
                    color: '#FF4444',
                    intensity: 0.5,
                    distance: 3
                });
                
                // Apply random color mixin
                const colors = ['red-sphere', 'blue-sphere', 'green-sphere'];
                const randomColor = colors[Math.floor(Math.random() * colors.length)];
                sphere.setAttribute('mixin', randomColor);
                
                // Add physics
                sphere.setAttribute('dynamic-body', {
                    shape: 'sphere',
                    mass: 0,
                    linearDamping: 0.99,
                    angularDamping: 0.99
                });
                
                // Click handler
                sphere.addEventListener('click', () => {
                    this.handleSphereClick(sphere);
                });
                
                // Gaze fuse handler
                sphere.addEventListener('fusing', (e) => {
                    sphere.setAttribute('material', 'color', '#00FF88');
                });
                
                sphere.addEventListener('mouseleave', (e) => {
                    const mixin = sphere.getAttribute('mixin');
                    if (mixin === 'red-sphere') sphere.setAttribute('material', 'color', '#FF4444');
                    else if (mixin === 'blue-sphere') sphere.setAttribute('material', 'color', '#4444FF');
                    else if (mixin === 'green-sphere') sphere.setAttribute('material', 'color', '#44FF44');
                });
                
                this.container.appendChild(sphere);
                gameState.activeSpheres.push(sphere);
                
                return sphere;
            },
            
            getRandomPosition() {
                const x = (Math.random() - 0.5) * 8;
                const y = 1.5 + Math.random() * 3;
                const z = -3 - Math.random() * 4;
                return `${x} ${y} ${z}`;
            },
            
            handleSphereClick(sphere) {
                // Remove sphere
                const index = gameState.activeSpheres.indexOf(sphere);
                if (index > -1) {
                    gameState.activeSpheres.splice(index, 1);
                }
                
                // Visual effects
                this.createExplosionEffect(sphere.getAttribute('position'));
                
                // Update game state
                gameState.targetsHit++;
                gameState.totalTargets++;
                gameState.score += TRAINING_MODES[gameState.currentMode].points;
                
                // Play sound
                audioManager.playHit();
                
                // Update accuracy
                this.updateAccuracy();
                
                // Check for level up
                this.checkLevelUp();
                
                // Remove sphere
                sphere.parentNode.removeChild(sphere);
            },
            
            createExplosionEffect(position) {
                const explosion = document.createElement('a-entity');
                explosion.setAttribute('position', position);
                explosion.setAttribute('geometry', { primitive: 'sphere', radius: 0.1 });
                explosion.setAttribute('material', { color: '#FFFF00', shader: 'flat' });
                explosion.setAttribute('light', {
                    type: 'point',
                    color: '#FFFF00',
                    intensity: 2,
                    distance: 5
                });
                
                explosion.setAttribute('animation', {
                    property: 'scale',
                    to: '3 3 3',
                    dur: 300,
                    easing: 'easeOutQuad'
                });
                
                explosion.setAttribute('animation__fade', {
                    property: 'material.opacity',
                    to: 0,
                    dur: 300,
                    easing: 'easeOutQuad'
                });
                
                this.effects.appendChild(explosion);
                
                setTimeout(() => {
                    if (explosion.parentNode) {
                        explosion.parentNode.removeChild(explosion);
                    }
                }, 300);
            },
            
            updateAccuracy() {
                gameState.accuracy = gameState.totalTargets > 0 ? 
                    Math.round((gameState.targetsHit / gameState.totalTargets) * 100) : 0;
            },
            
            checkLevelUp() {
                if (gameState.score >= gameState.levelThreshold) {
                    gameState.level++;
                    gameState.levelThreshold = gameState.level * 50;
                    
                    this.showNotification(
                        `Level ${gameState.level} Unlocked!`,
                        "Your cerebellar training is progressing well!"
                    );
                    
                    audioManager.playSuccess();
                }
            },
            
            clearAllSpheres() {
                gameState.activeSpheres.forEach(sphere => {
                    if (sphere.parentNode) {
                        sphere.parentNode.removeChild(sphere);
                    }
                });
                gameState.activeSpheres = [];
            },
            
            spawnPattern() {
                if (!TRAINING_MODES[gameState.currentMode].patterns) return;
                
                const patterns = [
                    // Circle pattern
                    () => {
                        const radius = 2;
                        const count = 6;
                        for (let i = 0; i < count; i++) {
                            const angle = (i / count) * Math.PI * 2;
                            const x = Math.cos(angle) * radius;
                            const z = Math.sin(angle) * radius - 5;
                            this.createSphere(`${x} 2 ${z}`);
                        }
                    },
                    
                    // Grid pattern
                    () => {
                        for (let x = -2; x <= 2; x += 1) {
                            for (let z = -3; z <= -7; z -= 1) {
                                this.createSphere(`${x} 2 ${z}`);
                            }
                        }
                    },
                    
                    // Random cluster
                    () => {
                        const baseX = (Math.random() - 0.5) * 4;
                        const baseZ = -5 - Math.random() * 3;
                        for (let i = 0; i < 4; i++) {
                            const x = baseX + (Math.random() - 0.5) * 2;
                            const z = baseZ + (Math.random() - 0.5) * 2;
                            this.createSphere(`${x} 2 ${z}`);
                        }
                    }
                ];
                
                const randomPattern = patterns[Math.floor(Math.random() * patterns.length)];
                randomPattern();
            }
        };

        // Training Manager
        const trainingManager = {
            spawnInterval: null,
            sessionTimer: null,
            
            start() {
                if (gameState.isTraining) return;
                
                gameState.isTraining = true;
                gameState.sessionStartTime = Date.now();
                
                // Clear existing spheres
                sphereManager.clearAllSpheres();
                
                // Start spawning spheres
                const config = TRAINING_MODES[gameState.currentMode];
                this.spawnInterval = setInterval(() => {
                    if (gameState.activeSpheres.length < config.sphereCount) {
                        if (config.patterns && Math.random() > 0.7) {
                            sphereManager.spawnPattern();
                        } else {
                            sphereManager.createSphere();
                        }
                    }
                }, config.spawnRate);
                
                // Start session timer
                this.sessionTimer = setInterval(() => {
                    gameState.sessionTime = Math.floor((Date.now() - gameState.sessionStartTime) / 1000);
                    this.updateLearningRate();
                    this.updateUI();
                }, 1000);
                
                this.updateUI();
            },
            
            stop() {
                gameState.isTraining = false;
                
                if (this.spawnInterval) {
                    clearInterval(this.spawnInterval);
                    this.spawnInterval = null;
                }
                
                if (this.sessionTimer) {
                    clearInterval(this.sessionTimer);
                    this.sessionTimer = null;
                }
                
                sphereManager.clearAllSpheres();
            },
            
            reset() {
                this.stop();
                
                gameState.score = 0;
                gameState.targetsHit = 0;
                gameState.totalTargets = 0;
                gameState.accuracy = 0;
                gameState.sessionTime = 0;
                gameState.learningRate = 0;
                gameState.level = 1;
                gameState.levelThreshold = 50;
                
                this.updateUI();
            },
            
            updateLearningRate() {
                // Calculate learning rate based on recent performance
                const timeFactor = Math.min(1, gameState.sessionTime / 60);
                const accuracyFactor = gameState.accuracy / 100;
                const levelFactor = gameState.level / 10;
                
                gameState.learningRate = Math.round(
                    (timeFactor * 0.3 + accuracyFactor * 0.5 + levelFactor * 0.2) * 100
                );
            },
            
            updateUI() {
                document.getElementById('score').textContent = gameState.score;
                document.getElementById('targets-hit').textContent = gameState.targetsHit;
                document.getElementById('accuracy').textContent = `${gameState.accuracy}%`;
                document.getElementById('learning-rate').textContent = `${gameState.learningRate}%`;
                document.getElementById('level').textContent = gameState.level;
                document.getElementById('next-level').textContent = `${gameState.levelThreshold} points`;
                
                // Update session time
                const minutes = Math.floor(gameState.sessionTime / 60);
                const seconds = gameState.sessionTime % 60;
                document.getElementById('session-time').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                // Update progress bar
                const progress = Math.min(100, (gameState.score / gameState.levelThreshold) * 100);
                document.getElementById('progress-fill').style.width = `${progress}%`;
            },
            
            showCompletionMessage() {
                sphereManager.showNotification(
                    "Training Complete!",
                    `Final Score: ${gameState.score}\nAccuracy: ${gameState.accuracy}%\nLearning Rate: ${gameState.learningRate}%`
                );
            }
        };

        // UI Functions
        function changeMode(mode) {
            gameState.currentMode = mode;
            if (gameState.isTraining) {
                trainingManager.stop();
                trainingManager.start();
            }
        }

        function startTraining() {
            trainingManager.start();
            document.getElementById('start-btn').textContent = 'Stop Training';
            document.getElementById('start-btn').onclick = stopTraining;
        }

        function stopTraining() {
            trainingManager.stop();
            document.getElementById('start-btn').textContent = 'Start Training';
            document.getElementById('start-btn').onclick = startTraining;
        }

        function resetTraining() {
            trainingManager.reset();
        }

        function toggleVR() {
            const scene = document.querySelector('a-scene');
            if (gameState.isVRMode) {
                scene.exitVR();
                document.body.classList.remove('vr-mode');
                gameState.isVRMode = false;
            } else {
                scene.enterVR();
                document.body.classList.add('vr-mode');
                gameState.isVRMode = true;
            }
        }

        function showNotification(title, message) {
            sphereManager.showNotification(title, message);
        }

        function hideNotification() {
            document.getElementById('notification').style.display = 'none';
        }

        // Performance Monitoring
        function initPerformanceMonitor() {
            const stats = new Stats();
            stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
            document.getElementById('performance-stats').appendChild(stats.dom);
            
            function animate() {
                stats.begin();
                // monitored code goes here
                stats.end();
                requestAnimationFrame(animate);
            }
            
            requestAnimationFrame(animate);
            
            // Check performance and show warning if needed
            setInterval(() => {
                const fps = stats.getFps();
                if (fps < 45) {
                    document.getElementById('performance-warning').style.display = 'block';
                } else {
                    document.getElementById('performance-warning').style.display = 'none';
                }
            }, 5000);
        }

        // Extend sphereManager with notification method
        sphereManager.showNotification = function(title, message) {
            const notification = document.getElementById('notification');
            document.getElementById('notification-title').textContent = title;
            document.getElementById('notification-message').textContent = message;
            notification.style.display = 'block';
        };

        // Initialize everything when the scene loads
        document.querySelector('a-scene').addEventListener('loaded', () => {
            audioManager.init();
            trainingManager.updateUI();
            initPerformanceMonitor();
            
            // Add VR event listeners
            document.querySelector('a-scene').addEventListener('enter-vr', () => {
                document.body.classList.add('vr-mode');
                gameState.isVRMode = true;
            });
            
            document.querySelector('a-scene').addEventListener('exit-vr', () => {
                document.body.classList.remove('vr-mode');
                gameState.isVRMode = false;
            });
        });

        // Auto-start training for demo purposes
        setTimeout(() => {
            startTraining();
        }, 2000);
    </script>
</body>
</html>
