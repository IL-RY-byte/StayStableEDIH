<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>StayStable - Cerebellar Rehabilitation VR</title>
    
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.min.js"></script>
    
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        .crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            pointer-events: none;
        }
        .crosshair::before, .crosshair::after { content: ''; position: absolute; background: white; box-shadow: 0 0 4px rgba(0, 0, 0, 0.5); }
        .crosshair::before { width: 2px; height: 20px; left: 50%; top: 50%; transform: translate(-50%, -50%); }
        .crosshair::after { width: 20px; height: 2px; left: 50%; top: 50%; transform: translate(-50%, -50%); }
        .data-panel { position: fixed; top: 20px; right: 20px; background: rgba(118, 75, 162, 0.9); color: white; padding: 15px; border-radius: 10px; z-index: 999; min-width: 200px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        .point-message { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(102, 126, 234, 0.95); color: white; padding: 15px; border-radius: 10px; z-index: 999; text-align: center; opacity: 1; transition: opacity 0.5s; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); }
        .point-message.fade { opacity: 0; }
        #orientation-message { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); color: white; display: flex; justify-content: center; align-items: center; font-size: 24px; text-align: center; z-index: 1000; }
        .out-of-bounds-message { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255, 0, 0, 0.8); color: white; padding: 20px; border-radius: 10px; font-size: 1.5rem; z-index: 1001; display: none; }
        .progress-bar { position: fixed; bottom: 70px; left: 50%; transform: translateX(-50%); width: 300px; height: 20px; background: rgba(255, 255, 255, 0.2); border-radius: 10px; overflow: hidden; z-index: 999; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
        .progress-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #667eea, #764ba2); transition: width 0.5s; }
        .session-stats { position: fixed; bottom: 20px; right: 20px; background: rgba(118, 75, 162, 0.9); color: white; padding: 15px; border-radius: 10px; z-index: 999; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        .instructions, .mode-selector { display: none !important; }
        .menu-button, .game-control-button { cursor: pointer; }
        body.vr-mode .data-panel,
        body.vr-mode .session-stats,
        body.vr-mode .progress-bar { display: none !important; }
        body.vr-mode .crosshair { display: block !important; }
        
        #manual-vr-button {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 25px;
            background: #007AFF;
            color: white;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            z-index: 10001;
            cursor: pointer;
        }
        body.vr-mode #manual-vr-button {
            display: none;
        }
    </style>
</head>
<body>
    <div id="orientation-message" style="display: none;"></div>
    <div class="crosshair"></div>
    <div class="data-panel">
        <div>Score: <span id="score">0</span></div>
        <div>Focus quality: <span id="focus-quality">0%</span></div>
        <div>Prediction: <span id="learning-rate">0%</span></div>
    </div>
    <div class="progress-bar"><div class="progress-fill"></div></div>
    <div class="point-message" style="display: none;"></div>
    <div class="out-of-bounds-message"></div>
    <div class="session-stats">
        <div>Session time: <span id="session-time">00:00</span></div>
        <div>Targets hit: <span id="targets-hit">0</span></div>
    </div>
    
    <button id="manual-vr-button">Enter Fullscreen / VR</button>

    <a-scene vr-mode-ui="enabled: false" device-orientation-permission-ui="enabled: true" renderer="antialias: true;">
        
        <a-camera position="0 1.6 0" 
            look-controls="magicWindowTrackingEnabled: true" 
            camera="near: 0.1; far: 1000;"
            raycaster="objects: .menu-button, .hotspot, .game-control-button; far: 1000;"
            cursor="fuse: true; fuseTimeout: 2000">
            
            <a-entity
                position="0 0 -1"
                geometry="primitive: ring; radiusInner: 0.01; radiusOuter: 0.02"
                material="color: white; shader: flat"> 
            </a-entity> 
        </a-camera>

        <a-sky color="black"></a-sky>
        
        <a-entity id="hotspots"></a-entity>
        <a-entity id="path-indicators"></a-entity>
        <a-entity id="menu-container" position="0 1.6 -2.5"></a-entity>
        <a-entity id="in-game-controls-container"></a-entity>
        
    </a-scene>

    <script>
        // *** ОНОВЛЕННЯ: Радіуси (radius) збільшено для більшої області взаємодії ***
        const CONFIG = {
            pursuit: {
                name: "Pursuit",
                description: "Track moving targets.",
                baseFuseTimeout: 1000,
                totalReps: 10,
                minDistance: 3, 
                maxDistance: 6,
                stages: [
                    { name: 'static_1', radius: 0.35 },
                    { name: 'static_2', radius: 0.30 },
                    { name: 'static_3', radius: 0.25 }
                ]
            },
            prediction: {
                name: "Prediction",
                description: "Anticipate target paths.",
                baseFuseTimeout: 1500,
                totalReps: 10,
                moveArea: { x: 2.5, y: 1.2, z: -4 },
                stages: [
                    { name: 'horizontal', dur: 4000, radius: 0.35 },
                    { name: 'vertical',   dur: 3000, radius: 0.35 },
                    { name: 'diagonal',   dur: 4000, radius: 0.30 }
                ]
            },
            coordination: {
                name: "Coordination",
                description: "Track multiple complex targets.",
                baseFuseTimeout: 800,
                totalReps: 10,
                moveArea: { x: 2.5, y: 1.2, z: -4 },
                stages: [
                    { name: 'square',   dur: 8000, radius: 0.35 },
                    { name: 'triangle', dur: 6000, radius: 0.30 },
                    { name: 'circle',   dur: 5000, radius: 0.25 }
                ]
            }
        };
        
        let ACTIVE_CONFIG = JSON.parse(JSON.stringify(CONFIG.prediction)); 
        let selectedModeButton = null;
        let confirmButton = null; 
        
        let SESSION_STATE = {
            currentModeKey: 'prediction',
            currentStage: 0,
            repsCompleted: 0
        };
        
        const LEARNING_DATA = {
            fastComponent: 0, slowComponent: 0, totalLearning: 0,
            decayRate: { fast: 0.15, slow: 0.04 },
            trials: 0, targetsHit: 0, sessionStartTime: 0, focusQuality: 0,
            cursorHistory: [], cursorVelocity: { x: 0, y: 0, z: 0 },
            anticipationScore: 0, trackingAccuracy: 0, predictionEfficiency: 0
        };
        
        let currentStageData = [];

        let lastCursorPos = null;
        let cursorUpdateInterval = null;
        let isTrainingActive = false;
        let synth;
        let isAudioInitialized = false;
        
        // --- WebSocket (Логіка "лікаря") ПОВНІСТЮ ВИДАЛЕНО ---

        async function initAudio() {
            if (isAudioInitialized) return;
            try {
                await Tone.start();
                console.log("Audio Context Started (iOS fix)");
                synth = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.5, release: 0.4 } }).toDestination();
                window.successSound = () => { synth.triggerAttackRelease("C5", "16n"); setTimeout(() => synth.triggerAttackRelease("E5", "16n"), 100); setTimeout(() => synth.triggerAttackRelease("G5", "16n"), 200); };
                window.errorSound = () => { synth.triggerAttackRelease("A3", "16n"); setTimeout(() => synth.triggerAttackRelease("G3", "16n"), 150); };
                window.focusSound = (quality) => { const note = 60 + Math.floor(quality / 5); const freq = Tone.Frequency(note, "midi").toFrequency(); synth.triggerAttackRelease(freq, "32n"); };
                isAudioInitialized = true;
            } catch (e) {
                console.error("Failed to initialize audio:", e);
            }
        }

        const scene = document.querySelector('a-scene');
        const hotspotsContainer = document.querySelector('#hotspots');
        const pathIndicators = document.querySelector('#path-indicators');
        const menuContainer = document.getElementById('menu-container');
        const inGameControlsContainer = document.getElementById('in-game-controls-container');
        const pointMessage = document.querySelector('.point-message');
        const orientationMessage = document.getElementById('orientation-message');
        const outOfBoundsMessage = document.querySelector('.out-of-bounds-message');
        const progressFill = document.querySelector('.progress-fill');
        const scoreEl = document.getElementById('score');
        const focusQualityEl = document.getElementById('focus-quality');
        const learningRateEl = document.getElementById('learning-rate');
        const sessionTimeEl = document.getElementById('session-time');
        const targetsHitEl = document.getElementById('targets-hit');
        const manualVRButton = document.getElementById('manual-vr-button'); 

        let activeHotspots = [];
        let predictivePattern = [];
        let learningProgress = 0;
        let sessionTimer = null;
        let isVRMode = false;
        
        function updateCursorTracking() {
            if (!isTrainingActive) return;
            const camera = document.querySelector('a-camera');
            if (!camera) return;
            const cameraRotation = camera.getAttribute('rotation');
            if (!cameraRotation) return; 
            const currentPos = { x: cameraRotation.y, y: cameraRotation.x, z: 0, timestamp: Date.now() };
            if (lastCursorPos) {
                const dt = (currentPos.timestamp - lastCursorPos.timestamp) / 1000;
                if (dt > 0) { LEARNING_DATA.cursorVelocity = { x: (currentPos.x - lastCursorPos.x) / dt, y: (currentPos.y - lastCursorPos.y) / dt, z: 0 }; }
            }
            LEARNING_DATA.cursorHistory.push(currentPos);
            if (LEARNING_DATA.cursorHistory.length > 10) { LEARNING_DATA.cursorHistory.shift(); }
            lastCursorPos = currentPos;
            calculateTrackingMetrics();
        }
        function getTargetCursorDistance(target) {
            const camera = document.querySelector('a-camera');
            if (!camera) return {x:0,y:0,z:0}; 
            const cameraRotation = camera.getAttribute('rotation');
            if (!cameraRotation) return {x:0,y:0,z:0}; 
            const targetPos = target.getAttribute('position');
            const dx = Math.atan2(targetPos.x, -targetPos.z) * (180 / Math.PI);
            const dy = Math.atan2(targetPos.y, -targetPos.z) * (180 / Math.PI);
            const angularDistance = Math.sqrt(Math.pow(dx - cameraRotation.y, 2) + Math.pow(dy - cameraRotation.x, 2));
            return angularDistance;
        }
        function predictCursorPosition(timeAhead) {
            if (!lastCursorPos) return null;
            return { x: lastCursorPos.x + LEARNING_DATA.cursorVelocity.x * timeAhead, y: lastCursorPos.y + LEARNING_DATA.cursorVelocity.y * timeAhead };
        }
        function calculateTrackingMetrics() {
            if (activeHotspots.length === 0 || !isTrainingActive) return;
            let nearestTarget = null;
            let minDistance = Infinity;
            activeHotspots.forEach(target => {
                const dist = getTargetCursorDistance(target);
                if (dist < minDistance) { minDistance = dist; nearestTarget = target; }
            });
            if (!nearestTarget) return;
            LEARNING_DATA.trackingAccuracy = Math.max(0, 100 - minDistance * 10);
            const predictedPos = predictCursorPosition(0.5);
            if (predictedPos) {
                const targetPos = nearestTarget.getAttribute('position');
                const predictedDx = Math.atan2(targetPos.x, -targetPos.z) * (180 / Math.PI);
                const predictedDy = Math.atan2(targetPos.y, -targetPos.z) * (180 / Math.PI);
                const predictedDistance = Math.sqrt(Math.pow(predictedDx - predictedPos.x, 2) + Math.pow(predictedDy - predictedPos.y, 2));
                LEARNING_DATA.anticipationScore = Math.max(0, 100 - predictedDistance * 8);
            }
            LEARNING_DATA.predictionEfficiency = (LEARNING_DATA.trackingAccuracy * 0.4) + (LEARNING_DATA.anticipationScore * 0.6);
            updateLearningUI();
        }
        
        function initSession() {
            hideMenu();
            
            SESSION_STATE.currentModeKey = ACTIVE_CONFIG.name.toLowerCase();
            SESSION_STATE.currentStage = 0;
            SESSION_STATE.repsCompleted = 0;
            currentStageData = []; 
            
            LEARNING_DATA.sessionStartTime = Date.now();
            LEARNING_DATA.trials = 0;
            LEARNING_DATA.targetsHit = 0;
            LEARNING_DATA.fastComponent = 0;
            LEARNING_DATA.slowComponent = 0;
            LEARNING_DATA.totalLearning = 0;
            LEARNING_DATA.focusQuality = 0;
            
            lastCursorPos = null;
            isTrainingActive = true;
            
            // *** ВИПРАВЛЕНО: Спочатку очищуємо, ПОТІМ додаємо кнопку ***
            clearAllGameElements(false); 
            createInGameExitButton(); // Створюємо червону кнопку на початку
            
            updateLearningUI();
            updateScoreUI();
            
            if (sessionTimer) clearInterval(sessionTimer);
            sessionTimer = setInterval(updateSessionTime, 1000);
            
            if (cursorUpdateInterval) clearInterval(cursorUpdateInterval);
            cursorUpdateInterval = setInterval(updateCursorTracking, 50);

            spawnNextHotspot();
        }
        

        // *** START: ЛОГІКА АДАПТИВНОЇ СКЛАДНОСТІ ("ШІ") ***
        function calculateAveragePerformance(stageData) {
            if (stageData.length === 0) return 50; 

            let totalScore = 0;
            stageData.forEach(data => {
                const repScore = (data.focus * 0.4) + (data.tracking * 0.3) + (data.anticipation * 0.3);
                totalScore += repScore;
            });
            
            return totalScore / stageData.length;
        }

        function adaptDifficulty(performanceScore, nextStageConfig) {
            if (!nextStageConfig) return; 

            const baseFuse = ACTIVE_CONFIG.baseFuseTimeout;
            
            console.log(`--- AI ADAPTATION ---`);
            console.log(`Performance Score: ${performanceScore.toFixed(2)}`);

            if (performanceScore < 40) {
                console.log(`Action: Making next stage EASIER.`);
                if (nextStageConfig.dur) nextStageConfig.dur *= 1.20; 
                ACTIVE_CONFIG.baseFuseTimeout = Math.min(baseFuse * 1.25, 2500);
                if (nextStageConfig.radius) nextStageConfig.radius *= 1.15; 

            } else if (performanceScore > 80) {
                console.log(`Action: Making next stage HARDER.`);
                if (nextStageConfig.dur) nextStageConfig.dur *= 0.80;
                ACTIVE_CONFIG.baseFuseTimeout = Math.max(baseFuse * 0.80, 500);
                if (nextStageConfig.radius) nextStageConfig.radius *= 0.90;
            
            } else {
                console.log(`Action: Difficulty remains the same.`);
            }

            console.log(`New 'dur': ${nextStageConfig.dur}, New 'fuse': ${ACTIVE_CONFIG.baseFuseTimeout}, New 'radius': ${nextStageConfig.radius}`);
            console.log(`---------------------`);
        }
        // *** END: ЛОГІКА АДАПТИВНОЇ СКЛАДНОСТІ ("ШІ") ***
        
        // *** ОНОВЛЕННЯ: Ця функція тепер генерує 1 кульку за раз ***
        function spawnNextHotspot() {
            const modeConfig = ACTIVE_CONFIG; 
            
            // 1. Перевіряємо, чи завершено етап
            if (SESSION_STATE.repsCompleted >= modeConfig.totalReps) {
                
                const performanceScore = calculateAveragePerformance(currentStageData);
                
                SESSION_STATE.currentStage++; 
                SESSION_STATE.repsCompleted = 0; 

                const nextStageConfig = modeConfig.stages[SESSION_STATE.currentStage];
                adaptDifficulty(performanceScore, nextStageConfig);
                
                currentStageData = []; 

                // 2. Перевіряємо, чи завершено весь режим
                if (SESSION_STATE.currentStage >= modeConfig.stages.length) {
                    console.log("Mode complete!");
                    showMilestoneMessage("Mode Complete!"); 
                    createContinueButton(); // "Continue" (посередині)
                    return;
                } else {
                    console.log("Stage complete! Moving to next level.");
                    showMilestoneMessage("Stage Complete!");
                    createNextStageButton(); // "Next Stage" (праворуч)
                    return; 
                }
            }

            // 3. Якщо це новий раунд, видаляємо старі зелені кнопки
            const existingGreenButton = document.querySelector('#in-game-controls-container a-sphere[color="#4CAF50"]');
            if (existingGreenButton && existingGreenButton.parentNode) {
                existingGreenButton.parentNode.parentNode.removeChild(existingGreenButton.parentNode);
            }

            // 4. Отримуємо конфігурацію поточного етапу
            const currentStageConfig = modeConfig.stages[SESSION_STATE.currentStage];
            const currentStageName = currentStageConfig.name;
            
            // *** ОНОВЛЕННЯ: Радіус береться з КОНФІГУРАЦІЇ ***
            const radius = currentStageConfig.radius || 0.35; // Збільшений радіус за замовчуванням
            const duration = currentStageConfig.dur || 5000;
            const moveArea = modeConfig.moveArea || { x: 2.5, y: 1.2, z: -4 };
            
            const hotspot = document.createElement('a-entity');
            let animationAttributes = {};
            let startPosition = '0 1.6 -4'; 
            let circleParent = null;
            
            switch (currentStageName) {
                case 'static_1':
                case 'static_2':
                case 'static_3':
                    const x = (Math.random() * 3) - 1.5; 
                    const y = (Math.random() * 2) - 0.5 + 1.6; 
                    const z = -(Math.random() * (modeConfig.maxDistance - modeConfig.minDistance) + modeConfig.minDistance);
                    startPosition = `${x} ${y} ${z}`;
                    break;
                case 'horizontal':
                    startPosition = `-${moveArea.x} ${Math.random() * moveArea.y + 1} ${moveArea.z}`;
                    animationAttributes = { property: 'position', to: `${moveArea.x} ${startPosition.split(' ')[1]} ${moveArea.z}`, dur: duration, easing: 'linear' };
                    break;
                case 'vertical':
                    startPosition = `${(Math.random() * moveArea.x*2) - moveArea.x} 1 ${moveArea.z}`;
                    animationAttributes = { property: 'position', to: `${startPosition.split(' ')[0]} ${moveArea.y + 1} ${moveArea.z}`, dur: duration, easing: 'linear' };
                    break;
                case 'diagonal':
                    startPosition = `-${moveArea.x} 1 ${moveArea.z}`;
                    animationAttributes = { property: 'position', to: `${moveArea.x} ${moveArea.y + 1} ${moveArea.z}`, dur: duration, easing: 'linear' };
                    break;
                case 'square':
                    startPosition = `-${moveArea.x/2} 1.3 ${moveArea.z}`;
                    animationAttributes = {
                        property: 'position',
                        path: [
                            `-${moveArea.x/2} 1.3 ${moveArea.z}`,
                            `${moveArea.x/2} 1.3 ${moveArea.z}`,
                            `${moveArea.x/2} ${moveArea.y + 0.7} ${moveArea.z}`,
                            `-${moveArea.x/2} ${moveArea.y + 0.7} ${moveArea.z}`,
                            `-${moveArea.x/2} 1.3 ${moveArea.z}`
                        ].join(','),
                        dur: duration, 
                        easing: 'linear',
                        loop: true
                    };
                    break;
                case 'triangle':
                    startPosition = `0 1 ${moveArea.z}`;
                    animationAttributes = {
                        property: 'position',
                        path: [
                            `0 1 ${moveArea.z}`,
                            `${moveArea.x/2} ${moveArea.y + 1} ${moveArea.z}`,
                            `-${moveArea.x/2} ${moveArea.y + 1} ${moveArea.z}`,
                            `0 1 ${moveArea.z}`
                        ].join(','),
                        dur: duration,
                        easing: 'linear',
                        loop: true
                    };
                    break;
                case 'circle':
                    circleParent = document.createElement('a-entity'); 
                    circleParent.setAttribute('position', `0 1.6 ${moveArea.z}`);
                    hotspot.setAttribute('position', `${moveArea.x / 2} 0 0`); 
                    circleParent.setAttribute('animation__rotation', {
                        property: 'rotation',
                        to: '0 360 0',
                        dur: duration,
                        easing: 'linear',
                        loop: true
                    });
                    break;
            }

            hotspot.setAttribute('position', startPosition);
            // *** ОНОВЛЕННЯ: Радіус тепер береться з 'radius' ***
            hotspot.setAttribute('geometry', { primitive: 'sphere', radius: radius });
            hotspot.setAttribute('material', { shader: 'standard', color: '#667eea', emissive: '#764ba2', emissiveIntensity: 0.8 });
            hotspot.setAttribute('class', 'hotspot');
            
            if (Object.keys(animationAttributes).length > 0) {
                hotspot.setAttribute('animation__move', animationAttributes);
            }

            const ring = document.createElement('a-entity');
            ring.setAttribute('geometry', { primitive: 'ring', radiusInner: radius * 1.33, radiusOuter: radius * 1.67, thetaLength: 0 });
            ring.setAttribute('material', { color: '#FFFFFF', opacity: 0.8, transparent: true, side: 'double' });
            ring.setAttribute('visible', false);
            hotspot.appendChild(ring);

            hotspot.dataset.focusStartTime = 0;
            hotspot.dataset.focusQuality = 0;

            const currentFuseTimeout = ACTIVE_CONFIG.baseFuseTimeout;

            hotspot.addEventListener('mouseenter', function() {
                hotspot.dataset.focusStartTime = Date.now();
                ring.setAttribute('visible', true);
                ring.setAttribute('animation__fill', { property: 'geometry.thetaLength', from: 0, to: 360, dur: currentFuseTimeout, easing: 'linear' });
            });
            hotspot.addEventListener('mouseleave', function() {
                ring.setAttribute('visible', false);
                ring.removeAttribute('animation__fill');
                ring.setAttribute('geometry', { primitive: 'ring', radiusInner: radius * 1.33, radiusOuter: radius * 1.67, thetaLength: 0 });
                hotspot.dataset.focusQuality = 0;
            });

            // *** ОНОВЛЕННЯ: 'click' тепер викликає 'spawnNextHotspot' ***
            hotspot.addEventListener('click', function() {
                const focusDuration = Date.now() - parseInt(hotspot.dataset.focusStartTime);
                const focusQuality = Math.min(100, (focusDuration / currentFuseTimeout) * 100);
                const enhancedQuality = (focusQuality * 0.4) + (LEARNING_DATA.trackingAccuracy * 0.3) + (LEARNING_DATA.anticipationScore * 0.3);
                LEARNING_DATA.focusQuality = enhancedQuality;
                if (isAudioInitialized) { window.focusSound(enhancedQuality); setTimeout(() => window.successSound(), 300); }
                
                currentStageData.push({
                    focus: enhancedQuality,
                    tracking: LEARNING_DATA.trackingAccuracy,
                    anticipation: LEARNING_DATA.anticipationScore
                });

                updateLearning(enhancedQuality); 
                LEARNING_DATA.targetsHit++;
                targetsHitEl.textContent = LEARNING_DATA.targetsHit;
                scoreEl.textContent = Math.floor(LEARNING_DATA.totalLearning);

                SESSION_STATE.repsCompleted++;

                this.setAttribute('animation__scale', { property: 'scale', dur: 300, to: '0 0 0', easing: 'easeInQuad' });
                
                const parentEl = this.parentNode;
                const entityToRemove = (parentEl === hotspotsContainer) ? this : parentEl;

                setTimeout(() => {
                    if (entityToRemove && entityToRemove.parentNode) {
                        entityToRemove.parentNode.removeChild(entityToRemove); 
                    }
                    // *** ОНОВЛЕННЯ: Викликаємо наступну кульку ***
                    spawnNextHotspot(); 
                }, 300);
            });

            if (currentStageName === 'circle' && circleParent) {
                circleParent.appendChild(hotspot);
                hotspotsContainer.appendChild(circleParent);
            } else {
                hotspotsContainer.appendChild(hotspot);
            }
            
            activeHotspots.push(hotspot); // Додаємо в масив для відстеження
        }
        
        function updateLearning(focusQuality) {
            LEARNING_DATA.trials++;
            const learningFactor = focusQuality / 100;
            if (LEARNING_DATA.trials < 20) { LEARNING_DATA.fastComponent += (10 * learningFactor); } else { LEARNING_DATA.fastComponent *= (1 - LEARNING_DATA.decayRate.fast); LEARNING_DATA.fastComponent += (5 * learningFactor); }
            LEARNING_DATA.slowComponent *= (1 - LEARNING_DATA.decayRate.slow);
            LEARNING_DATA.slowComponent += (2 * learningFactor * Math.log(LEARNING_DATA.trials + 1));
            LEARNING_DATA.totalLearning = LEARNING_DATA.fastComponent + LEARNING_DATA.slowComponent;
            learningProgress = Math.min(100, (LEARNING_DATA.totalLearning / 200) * 100);
            progressFill.style.width = `${learningProgress}%`;
            updateLearningUI();
        }
        function updateLearningUI() {
            focusQualityEl.textContent = `${Math.round(LEARNING_DATA.focusQuality)}%`;
            const learningRate = LEARNING_DATA.trials > 1 ? Math.round(LEARNING_DATA.predictionEfficiency) : 0;
            learningRateEl.textContent = `${learningRate}%`;
        }
        function showMilestoneMessage(customMessage = "") {
            let message = customMessage;
            if (!message) {
                 if (LEARNING_DATA.targetsHit > 0 && LEARNING_DATA.targetsHit % 10 === 0) {
                    message = `${LEARNING_DATA.targetsHit} targets hit! Keep going!`;
                 } else {
                     return; 
                 }
            }
            pointMessage.textContent = message;
            pointMessage.style.display = 'block';
            pointMessage.classList.remove('fade');
            setTimeout(() => { pointMessage.classList.add('fade'); setTimeout(() => { pointMessage.style.display = 'none'; }, 500); }, 3000); 
        }
        function updateSessionTime() {
            if (!isTrainingActive) return;
            const elapsedSec = Math.floor((Date.now() - LEARNING_DATA.sessionStartTime) / 1000);
            const minutes = Math.floor(elapsedSec / 60).toString().padStart(2, '0');
            const seconds = (elapsedSec % 60).toString().padStart(2, '0');
            sessionTimeEl.textContent = `${minutes}:${seconds}`;
        }
        function updateScoreUI() { scoreEl.textContent = Math.floor(LEARNING_DATA.totalLearning); }
        function checkOrientation() {
            if (!isVRMode && window.innerHeight > window.innerWidth) { orientationMessage.style.display = 'flex'; scene.pause(); }
            else { orientationMessage.style.display = 'none'; if(scene) scene.play(); }
        }
        function checkOutOfBounds() {
            if (!isTrainingActive) return; 
            const camera = document.querySelector('a-camera');
            if (!camera) return; 
            const cameraRotation = camera.getAttribute('rotation');
            if (!cameraRotation) return; 
            const yaw = cameraRotation.y; const pitch = cameraRotation.x;
            const yawLimit = 45; const pitchLimit = 30;
            if (Math.abs(yaw) > yawLimit || Math.abs(pitch) > pitchLimit) {
                outOfBoundsMessage.style.display = 'block';
                outOfBoundsMessage.textContent = 'Please return to center position';
                if (navigator.vibrate) { navigator.vibrate(200); }
                if (LEARNING_DATA.fastComponent > 0) { LEARNING_DATA.fastComponent *= 0.95; updateLearningUI(); }
            } else { outOfBoundsMessage.style.display = 'none'; }
        }

        function clearAllGameElements(stopSession = true) {
            if (stopSession) {
                isTrainingActive = false;
                if (sessionTimer) clearInterval(sessionTimer);
                if (cursorUpdateInterval) clearInterval(cursorUpdateInterval);
            }
            // Очищуємо активні кульки
            activeHotspots = [];
            
            while (hotspotsContainer.firstChild) { hotspotsContainer.removeChild(hotspotsContainer.firstChild); }
            while (pathIndicators.firstChild) { pathIndicators.removeChild(pathIndicators.firstChild); }
            while (inGameControlsContainer.firstChild) { inGameControlsContainer.removeChild(inGameControlsContainer.firstChild); }
        }
        
        // *** Кнопка "Вихід" (червона, ліворуч) ***
        function createInGameExitButton() {
            const exitBtn = document.createElement('a-entity');
            exitBtn.setAttribute('position', '-2.5 1.6 -2'); // Далі ліворуч
            const exitSphere = document.createElement('a-sphere');
            exitSphere.setAttribute('radius', '0.2');
            exitSphere.setAttribute('color', '#F44336'); // Червоний
            exitSphere.setAttribute('class', 'game-control-button');
            const exitText = document.createElement('a-text');
            exitText.setAttribute('value', 'Exit');
            exitText.setAttribute('position', '0 0.3 0');
            exitText.setAttribute('align', 'center');
            exitText.setAttribute('width', '2');
            exitText.setAttribute('font', 'roboto'); // Стандартний шрифт
            exitSphere.addEventListener('click', () => {
                clearAllGameElements(true);
                createMainMenu(); 
            });
            exitBtn.appendChild(exitSphere);
            exitBtn.appendChild(exitText);
            inGameControlsContainer.appendChild(exitBtn);
        }

        // *** Кнопка "Next Stage" (зелена, праворуч) ***
        function createNextStageButton() {
            while (hotspotsContainer.firstChild) { hotspotsContainer.removeChild(hotspotsContainer.firstChild); }
            
            const nextBtn = document.createElement('a-entity');
            nextBtn.setAttribute('position', '2.5 1.6 -2'); // Далі праворуч
            const nextSphere = document.createElement('a-sphere');
            nextSphere.setAttribute('radius', '0.2');
            nextSphere.setAttribute('color', '#4CAF50'); // Зелений
            nextSphere.setAttribute('class', 'game-control-button');
            const nextText = document.createElement('a-text');
            nextText.setAttribute('value', 'Next Stage'); 
            nextText.setAttribute('position', '0 0.3 0');
            nextText.setAttribute('align', 'center');
            nextText.setAttribute('width', '2');
            nextText.setAttribute('font', 'roboto'); // Стандартний шрифт
            nextSphere.addEventListener('click', () => {
                if(nextBtn.parentNode) {
                    nextBtn.parentNode.removeChild(nextBtn); 
                }
                spawnNextHotspot(); 
            });
            
            nextBtn.appendChild(nextSphere);
            nextBtn.appendChild(nextText);
            inGameControlsContainer.appendChild(nextBtn);
        }

        // *** Кнопка "Continue" (зелена, посередині) ***
        function createContinueButton() {
            clearAllGameElements(true); 
            
            const continueBtn = document.createElement('a-entity');
            continueBtn.setAttribute('position', '0 1.6 -2'); // Посередині
            const continueSphere = document.createElement('a-sphere');
            continueSphere.setAttribute('radius', '0.2');
            continueSphere.setAttribute('color', '#4CAF50'); // Зелений
            continueSphere.setAttribute('class', 'game-control-button');
            const continueText = document.createElement('a-text');
            continueText.setAttribute('value', 'Continue'); 
            continueText.setAttribute('position', '0 0.3 0');
            continueText.setAttribute('align', 'center');
            continueText.setAttribute('width', '2');
            continueText.setAttribute('font', 'roboto'); // Стандартний шрифт
            continueSphere.addEventListener('click', () => {
                clearAllGameElements(true); 
                createMainMenu(); 
            });
            
            continueBtn.appendChild(continueSphere);
            continueBtn.appendChild(continueText);
            inGameControlsContainer.appendChild(continueBtn);
        }


        function createMainMenu() {
            while (menuContainer.firstChild) {
                menuContainer.removeChild(menuContainer.firstChild);
            }
            menuContainer.setAttribute('visible', true);
            if (confirmButton) {
                if (confirmButton.parentNode) {
                    confirmButton.parentNode.removeChild(confirmButton);
                }
                confirmButton = null;
            }
            const title = document.createElement('a-text');
            title.setAttribute('value', 'StayStable VR');
            title.setAttribute('position', '0 0.8 0');
            title.setAttribute('align', 'center');
            title.setAttribute('width', '4');
            title.setAttribute('color', '#FFFFFF');
            title.setAttribute('font', 'roboto'); 
            menuContainer.appendChild(title);
            
            const modeTitle = document.createElement('a-text');
            modeTitle.setAttribute('value', 'Select Mode:');
            modeTitle.setAttribute('position', '-1.1 0.5 0');
            modeTitle.setAttribute('align', 'left');
            modeTitle.setAttribute('width', '3');
            modeTitle.setAttribute('color', '#DDDDDD');
            modeTitle.setAttribute('font', 'roboto'); 
            menuContainer.appendChild(modeTitle);
            
            const pursuitBtn = createMenuButton_Sphere({ text: 'Pursuit', position: '-1 0.2 0', mode: 'pursuit' });
            menuContainer.appendChild(pursuitBtn);
            const predictionBtn = createMenuButton_Sphere({ text: 'Prediction', position: '0 0.2 0', mode: 'prediction' });
            menuContainer.appendChild(predictionBtn);
            const coordBtn = createMenuButton_Sphere({ text: 'Coordination', position: '1 0.2 0', mode: 'coordination' });
            menuContainer.appendChild(coordBtn);

            // Виправлено: вибір режиму за замовчуванням
            const defaultModeKey = SESSION_STATE.currentModeKey || 'prediction';
            const defaultButton = menuContainer.querySelector(`a-sphere[data-mode="${defaultModeKey}"]`) || predictionBtn.querySelector('a-sphere');
            selectMode(defaultButton, defaultModeKey);
            
            const calibBtn = createMenuButton_Plane({ text: 'Calibration', details: 'Recenter view and sensors.', position: '-0.6 -0.4 0', width: 1.0, color: '#2196F3', onClick: () => console.log("Calibration clicked") });
            menuContainer.appendChild(calibBtn);
            const recBtn = createMenuButton_Plane({ text: 'Recommendations', details: 'View tips for this exercise.', position: '0.6 -0.4 0', width: 1.0, color: '#FF9800', onClick: () => console.log("Recommendations clicked") });
            menuContainer.appendChild(recBtn);
        }
        function createMenuButton_Plane(config) {
            const { text, details, position, width = 1, height = 0.3, color = '#667eea', onClick } = config;
            const button = document.createElement('a-entity');
            button.setAttribute('position', position);
            const plane = document.createElement('a-plane');
            plane.setAttribute('width', width);
            plane.setAttribute('height', height);
            plane.setAttribute('color', color);
            plane.setAttribute('class', 'menu-button');
            plane.dataset.originalColor = color;
            const label = document.createElement('a-text');
            label.setAttribute('value', text);
            label.setAttribute('position', '0 0 0.01');
            label.setAttribute('align', 'center');
            label.setAttribute('width', width * 2);
            label.setAttribute('color', '#FFFFFF');
            label.setAttribute('font', 'roboto'); 
            const detailText = document.createElement('a-text');
            detailText.setAttribute('value', details);
            detailText.setAttribute('position', `0 -${height / 1.5} 0.01`);
            detailText.setAttribute('align', 'center');
            detailText.setAttribute('width', width * 1.5);
            detailText.setAttribute('color', '#DDDDDD');
            detailText.setAttribute('visible', 'false');
            detailText.setAttribute('font', 'roboto'); 
            button.detailText = detailText;
            plane.addEventListener('mouseenter', () => {
                plane.setAttribute('color', '#FFFFFF');
                detailText.setAttribute('visible', 'true');
            });
            plane.addEventListener('mouseleave', () => {
                plane.setAttribute('color', color);
                detailText.setAttribute('visible', 'false');
            });
            if (onClick) {
                plane.addEventListener('click', onClick);
            }
            button.appendChild(plane);
            button.appendChild(label);
            button.appendChild(detailText);
            return button;
        }
        function createMenuButton_Sphere(config) {
            const { text, position, radius = 0.2, color = '#667eea', mode } = config;
            const button = document.createElement('a-entity');
            button.setAttribute('position', position);
            const sphere = document.createElement('a-entity');
            sphere.setAttribute('geometry', { primitive: 'sphere', radius: radius });
            sphere.setAttribute('material', { shader: 'standard', color: color, emissive: color, emissiveIntensity: 0.3 });
            sphere.setAttribute('class', 'menu-button');
            sphere.dataset.originalColor = color;
            sphere.dataset.mode = mode;
            const label = document.createElement('a-text');
            label.setAttribute('value', text);
            label.setAttribute('position', `0 ${radius + 0.1} 0`);
            label.setAttribute('align', 'center');
            label.setAttribute('width', '2');
            label.setAttribute('font', 'roboto'); 
            sphere.addEventListener('mouseenter', () => sphere.setAttribute('scale', '1.2 1.2 1.2'));
            sphere.addEventListener('mouseleave', () => sphere.setAttribute('scale', '1 1 1'));
            sphere.addEventListener('click', () => {
                selectMode(sphere, mode);
            });
            button.appendChild(sphere);
            button.appendChild(label);
            return button;
        }
        
        function selectMode(clickedButton, mode) {
            if (selectedModeButton) {
                selectedModeButton.setAttribute('material', { 
                    color: selectedModeButton.dataset.originalColor,
                    emissive: selectedModeButton.dataset.originalColor,
                    emissiveIntensity: 0.3
                });
            }
            clickedButton.setAttribute('material', { 
                color: '#FFFFFF', 
                emissive: '#FFFFFF',
                emissiveIntensity: 0.8
            });
            selectedModeButton = clickedButton;
            
            ACTIVE_CONFIG = JSON.parse(JSON.stringify(CONFIG[mode]));
            
            SESSION_STATE.currentModeKey = mode;
            
            if (confirmButton) {
                if (confirmButton.parentNode) {
                    confirmButton.parentNode.removeChild(confirmButton);
                }
                confirmButton = null;
            }

            const parentEntity = clickedButton.parentNode;
            const parentPosition = parentEntity.getAttribute('position');
            const newPos = `${parentPosition.x} -0.2 ${parentPosition.z}`; 

            confirmButton = document.createElement('a-entity');
            confirmButton.setAttribute('position', newPos);
            confirmButton.setAttribute('geometry', { primitive: 'sphere', radius: 0.1 });
            confirmButton.setAttribute('material', { color: '#4CAF50' }); 
            confirmButton.setAttribute('class', 'menu-button'); 
            confirmButton.setAttribute('animation__pulse', {
                property: 'scale',
                dir: 'alternate',
                dur: 700,
                from: '1 1 1',
                to: '1.2 1.2 1.2',
                loop: true
            });

            const text = document.createElement('a-text');
            text.setAttribute('value', 'Confirm');
            text.setAttribute('position', '0 0.15 0'); 
            text.setAttribute('align', 'center');
            text.setAttribute('width', 2);
            text.setAttribute('font', 'roboto'); 
            let gameHasStarted = false;
            
            const startGame = async (event) => {
                if (event.type === 'touchstart') {
                    event.preventDefault(); 
                }
                if (gameHasStarted) return; 
                gameHasStarted = true;
                
                console.log("StartGame called via", event.type);
                
                await initAudio(); 
                initSession();
            };

            confirmButton.addEventListener('click', startGame);
            confirmButton.addEventListener('touchstart', startGame); 

            confirmButton.appendChild(text);
            menuContainer.appendChild(confirmButton);
        }

        function hideMenu() {
            menuContainer.setAttribute('visible', 'false');
            if (confirmButton) {
                if (confirmButton.parentNode) {
                    confirmButton.parentNode.removeChild(confirmButton);
                }
                confirmButton = null;
            }
        }
        

        // Event listeners
        window.addEventListener('resize', checkOrientation);
        window.addEventListener('orientationchange', checkOrientation);
        
        scene.addEventListener('enter-vr', () => {
            isVRMode = true;
            document.body.classList.add('vr-mode');
        });
        
        scene.addEventListener('exit-vr', () => {
            isVRMode = false;
            document.body.classList.remove('vr-mode');
        });
        
        setInterval(checkOutOfBounds, 100);
        
        scene.addEventListener('loaded', () => {
            
            manualVRButton.addEventListener('click', async () => {
                await initAudio(); 
                try {
                    await scene.enterVR();
                } catch (e) {
                    console.error("Failed to enter VR:", e);
                    alert("Could not enter VR mode. Make sure permissions are granted.");
                }
            });

            if (scene.is('vr-mode')) {
                manualVRButton.style.display = 'none';
            }
            
            checkOrientation();
            createMainMenu();
        });
    </script>
</body>
</html>
