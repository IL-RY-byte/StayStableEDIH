<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StayStable - Cerebellar Rehabilitation VR</title>
    <!-- A-Frame for VR functionality -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/aframe/1.4.2/aframe.min.js"></script>
    <!-- Tone.js for audio feedback -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .instructions {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(102, 126, 234, 0.9);
            color: white;
            padding: 15px;
            border-radius: 10px;
            z-index: 999;
            max-width: 320px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            pointer-events: none;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: white;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
        }

        .crosshair::before {
            width: 2px;
            height: 20px;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .crosshair::after {
            width: 20px;
            height: 2px;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .data-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(118, 75, 162, 0.9);
            color: white;
            padding: 15px;
            border-radius: 10px;
            z-index: 999;
            min-width: 200px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .point-message {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(102, 126, 234, 0.95);
            color: white;
            padding: 15px;
            border-radius: 10px;
            z-index: 999;
            text-align: center;
            opacity: 1;
            transition: opacity 0.5s;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .point-message.fade {
            opacity: 0;
        }

        #orientation-message {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            text-align: center;
            z-index: 1000;
        }

        .field-of-view {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 110vw;
            height: 90vh;
            border-radius: 50%;
            pointer-events: none;
            z-index: 998;
        }

        .out-of-bounds-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-size: 1.5rem;
            z-index: 1001;
            display: none;
        }
        
        .progress-bar {
            position: fixed;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            z-index: 999;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.5s;
        }
        
        .session-stats {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(118, 75, 162, 0.9);
            color: white;
            padding: 15px;
            border-radius: 10px;
            z-index: 999;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .mode-selector {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(102, 126, 234, 0.9);
            color: white;
            padding: 15px;
            border-radius: 10px;
            z-index: 999;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        select, button {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 15px;
            border-radius: 5px;
            margin: 5px 0;
            cursor: pointer;
            font-weight: 500;
        }
        
        select:focus, button:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.5);
        }
        
        select:hover, button:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .hotspot {
            cursor: pointer;
        }
        
        /* VR Stereo Mode Styles */
        .vr-stereo-mode {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(102, 126, 234, 0.9);
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            z-index: 999;
            font-size: 18px;
            cursor: pointer;
            border: 2px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        
        .vr-stereo-mode:hover {
            background: rgba(118, 75, 162, 0.9);
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.5);
        }
        
        /* Stereo view container */
        .a-canvas.a-stereo {
            position: absolute !important;
        }
        
        /* Hide UI elements in VR mode */
        body.vr-mode .instructions,
        body.vr-mode .data-panel,
        body.vr-mode .session-stats,
        body.vr-mode .mode-selector,
        body.vr-mode .vr-stereo-mode,
        body.vr-mode .progress-bar {
            display: none !important;
        }
        
        body.vr-mode .crosshair {
            display: block !important;
        }
    </style>
</head>
<body>
    <div id="orientation-message" style="display: none;">
        Please rotate your device to landscape mode
    </div>

    <div class="instructions">
        <h3>Cerebellar Rehabilitation Exercise</h3>
        <p>Focus on dots and follow predictive patterns to train your cerebellum.</p>
        <p>Each successful focus improves motor learning pathways.</p>
    </div>

    <div class="crosshair"></div>
    <div class="field-of-view"></div>
    
    <div class="data-panel">
        <div>Score: <span id="score">0</span></div>
        <div>Focus quality: <span id="focus-quality">0%</span></div>
        <div>Prediction: <span id="learning-rate">0%</span></div>
    </div>

    <div class="progress-bar">
        <div class="progress-fill"></div>
    </div>

    <div class="point-message" style="display: none;"></div>
    <div class="out-of-bounds-message">Return to center position</div>
    
    <div class="session-stats">
        <div>Session time: <span id="session-time">00:00</span></div>
        <div>Targets hit: <span id="targets-hit">0</span></div>
    </div>
    
    <div class="mode-selector">
        <select id="training-mode">
            <option value="pursuit">Pursuit Learning</option>
            <option value="prediction">Prediction Training</option>
            <option value="coordination">Coordination Exercise</option>
        </select>
        <button id="start-training">Start Training</button>
    </div>
    
    <button class="vr-stereo-mode" id="vr-stereo-toggle">
        ðŸ¥½ Enable VR Stereo Mode
    </button>

    <a-scene raycaster="objects: .hotspot; far: 20" vr-mode-ui="enabled: true" device-orientation-permission-ui="enabled: true">
        <a-camera position="0 1.6 0" look-controls="magicWindowTrackingEnabled: true">
            <a-entity
                raycaster="objects: .hotspot; far: 20"
                position="0 0 -1"
                geometry="primitive: ring; radiusInner: 0.01; radiusOuter: 0.02"
                material="color: white; shader: flat"
                cursor="fuse: true; fuseTimeout: 1000"
                visible="false">
            </a-entity>
        </a-camera>

        <a-sky color="#f0e6ff"></a-sky>
        <a-entity id="hotspots"></a-entity>
        <a-entity id="path-indicators"></a-entity>
    </a-scene>

    <script>
        // Core settings
        const CONFIG = {
            pursuit: {
                numHotspots: 5,
                spawnDelay: 2000,
                minDistance: 3,
                maxDistance: 6,
                predictiveMode: false,
                fuseTimeout: 1000,
                moveSpeed: 0.02
            },
            prediction: {
                numHotspots: 3,
                spawnDelay: 3000,
                minDistance: 2,
                maxDistance: 5,
                predictiveMode: true,
                fuseTimeout: 1500,
                moveSpeed: 0.03
            },
            coordination: {
                numHotspots: 8,
                spawnDelay: 1500,
                minDistance: 2.5,
                maxDistance: 7,
                predictiveMode: true,
                fuseTimeout: 800,
                moveSpeed: 0.04
            }
        };
        
        // Current active configuration
        let ACTIVE_CONFIG = CONFIG.pursuit;
        
        // Learning data with cursor tracking
        const LEARNING_DATA = {
            fastComponent: 0,
            slowComponent: 0,
            totalLearning: 0,
            decayRate: {
                fast: 0.15,
                slow: 0.04
            },
            trials: 0,
            targetsHit: 0,
            sessionStartTime: 0,
            focusQuality: 0,
            cursorHistory: [],
            cursorVelocity: { x: 0, y: 0, z: 0 },
            anticipationScore: 0,
            trackingAccuracy: 0,
            predictionEfficiency: 0
        };

        // Cursor tracking variables
        let lastCursorPos = null;
        let cursorUpdateInterval = null;
        let isTrainingActive = false;

        // Audio synth setup
        let synth;
        let isAudioInitialized = false;
        
        function initAudio() {
            if (isAudioInitialized) return;
            
            synth = new Tone.Synth({
                oscillator: {
                    type: "sine"
                },
                envelope: {
                    attack: 0.01,
                    decay: 0.1,
                    sustain: 0.5,
                    release: 0.4
                }
            }).toDestination();
            
            window.successSound = () => {
                synth.triggerAttackRelease("C5", "16n");
                setTimeout(() => synth.triggerAttackRelease("E5", "16n"), 100);
                setTimeout(() => synth.triggerAttackRelease("G5", "16n"), 200);
            };
            
            window.errorSound = () => {
                synth.triggerAttackRelease("A3", "16n");
                setTimeout(() => synth.triggerAttackRelease("G3", "16n"), 150);
            };
            
            window.focusSound = (quality) => {
                const note = 60 + Math.floor(quality / 5);
                const freq = Tone.Frequency(note, "midi").toFrequency();
                synth.triggerAttackRelease(freq, "32n");
            };
            
            isAudioInitialized = true;
        }

        // Main DOM elements
        const scene = document.querySelector('a-scene');
        const hotspotsContainer = document.querySelector('#hotspots');
        const pathIndicators = document.querySelector('#path-indicators');
        const pointMessage = document.querySelector('.point-message');
        const orientationMessage = document.getElementById('orientation-message');
        const outOfBoundsMessage = document.querySelector('.out-of-bounds-message');
        const progressFill = document.querySelector('.progress-fill');
        const scoreEl = document.getElementById('score');
        const focusQualityEl = document.getElementById('focus-quality');
        const learningRateEl = document.getElementById('learning-rate');
        const sessionTimeEl = document.getElementById('session-time');
        const targetsHitEl = document.getElementById('targets-hit');
        const trainingModeEl = document.getElementById('training-mode');
        const startTrainingBtn = document.getElementById('start-training');
        const vrStereoToggle = document.getElementById('vr-stereo-toggle');

        // Hotspots tracking
        let activeHotspots = [];
        let predictivePattern = [];
        let learningProgress = 0;
        let sessionTimer = null;
        let isVRMode = false;
        
        // Calculate cursor velocity and update tracking
        function updateCursorTracking() {
            if (!isTrainingActive) return;
            
            const camera = document.querySelector('a-camera');
            if (!camera) return;
            
            const cameraRotation = camera.getAttribute('rotation');
            const currentPos = {
                x: cameraRotation.y,
                y: cameraRotation.x,
                z: 0,
                timestamp: Date.now()
            };
            
            if (lastCursorPos) {
                const dt = (currentPos.timestamp - lastCursorPos.timestamp) / 1000;
                if (dt > 0) {
                    LEARNING_DATA.cursorVelocity = {
                        x: (currentPos.x - lastCursorPos.x) / dt,
                        y: (currentPos.y - lastCursorPos.y) / dt,
                        z: 0
                    };
                }
            }
            
            LEARNING_DATA.cursorHistory.push(currentPos);
            if (LEARNING_DATA.cursorHistory.length > 10) {
                LEARNING_DATA.cursorHistory.shift();
            }
            
            lastCursorPos = currentPos;
            
            calculateTrackingMetrics();
        }
        
        // Calculate distance between cursor and target in screen space
        function getTargetCursorDistance(target) {
            const camera = document.querySelector('a-camera');
            const cameraRotation = camera.getAttribute('rotation');
            const targetPos = target.getAttribute('position');
            
            const dx = Math.atan2(targetPos.x, -targetPos.z) * (180 / Math.PI);
            const dy = Math.atan2(targetPos.y, -targetPos.z) * (180 / Math.PI);
            
            const angularDistance = Math.sqrt(
                Math.pow(dx - cameraRotation.y, 2) +
                Math.pow(dy - cameraRotation.x, 2)
            );
            
            return angularDistance;
        }
        
        // Predict where cursor will be based on velocity
        function predictCursorPosition(timeAhead) {
            if (!lastCursorPos) return null;
            
            return {
                x: lastCursorPos.x + LEARNING_DATA.cursorVelocity.x * timeAhead,
                y: lastCursorPos.y + LEARNING_DATA.cursorVelocity.y * timeAhead
            };
        }
        
        // Calculate tracking metrics
        function calculateTrackingMetrics() {
            if (activeHotspots.length === 0) return;
            
            let nearestTarget = null;
            let minDistance = Infinity;
            
            activeHotspots.forEach(target => {
                const dist = getTargetCursorDistance(target);
                if (dist < minDistance) {
                    minDistance = dist;
                    nearestTarget = target;
                }
            });
            
            if (!nearestTarget) return;
            
            LEARNING_DATA.trackingAccuracy = Math.max(0, 100 - minDistance * 10);
            
            const predictedPos = predictCursorPosition(0.5);
            if (predictedPos) {
                const targetPos = nearestTarget.getAttribute('position');
                const predictedDx = Math.atan2(targetPos.x, -targetPos.z) * (180 / Math.PI);
                const predictedDy = Math.atan2(targetPos.y, -targetPos.z) * (180 / Math.PI);
                
                const predictedDistance = Math.sqrt(
                    Math.pow(predictedDx - predictedPos.x, 2) +
                    Math.pow(predictedDy - predictedPos.y, 2)
                );
                
                LEARNING_DATA.anticipationScore = Math.max(0, 100 - predictedDistance * 8);
            }
            
            LEARNING_DATA.predictionEfficiency = 
                (LEARNING_DATA.trackingAccuracy * 0.4) + 
                (LEARNING_DATA.anticipationScore * 0.6);
            
            updateLearningUI();
        }
        
        // Initialize the session
        function initSession() {
            LEARNING_DATA.sessionStartTime = Date.now();
            LEARNING_DATA.trials = 0;
            LEARNING_DATA.targetsHit = 0;
            LEARNING_DATA.fastComponent = 0;
            LEARNING_DATA.slowComponent = 0;
            LEARNING_DATA.totalLearning = 0;
            LEARNING_DATA.focusQuality = 0;
            LEARNING_DATA.cursorHistory = [];
            LEARNING_DATA.cursorVelocity = { x: 0, y: 0, z: 0 };
            LEARNING_DATA.anticipationScore = 0;
            LEARNING_DATA.trackingAccuracy = 0;
            LEARNING_DATA.predictionEfficiency = 0;
            
            lastCursorPos = null;
            isTrainingActive = true;
            
            while (hotspotsContainer.firstChild) {
                hotspotsContainer.removeChild(hotspotsContainer.firstChild);
            }
            
            while (pathIndicators.firstChild) {
                pathIndicators.removeChild(pathIndicators.firstChild);
            }
            
            activeHotspots = [];
            
            updateLearningUI();
            updateScoreUI();
            
            if (sessionTimer) clearInterval(sessionTimer);
            sessionTimer = setInterval(updateSessionTime, 1000);
            
            if (cursorUpdateInterval) clearInterval(cursorUpdateInterval);
            cursorUpdateInterval = setInterval(updateCursorTracking, 50);
            
            for (let i = 0; i < ACTIVE_CONFIG.numHotspots; i++) {
                setTimeout(() => createHotspot(), i * 500);
            }
            
            if (ACTIVE_CONFIG.predictiveMode) {
                generatePredictivePattern();
            }
            
            document.addEventListener('click', initAudio, { once: true });
        }
        
        // Generate a predictable pattern for targets
        function generatePredictivePattern() {
            predictivePattern = [];
            const patternLength = 8;
            const radius = 3;
            
            for (let i = 0; i < patternLength; i++) {
                const angle = (i / patternLength) * Math.PI * 2;
                const x = radius * Math.sin(angle * 2) * 0.7;
                const y = radius * Math.sin(angle) * 0.3;
                const z = -radius * 1.5;
                
                predictivePattern.push({ x, y, z });
            }
            
            if (ACTIVE_CONFIG.predictiveMode) {
                visualizePredictivePattern();
            }
        }
        
        // Create visual cues for the predictive pattern
        function visualizePredictivePattern() {
            predictivePattern.forEach((pos, index) => {
                const indicator = document.createElement('a-entity');
                
                indicator.setAttribute('geometry', {
                    primitive: 'ring',
                    radiusInner: 0.05,
                    radiusOuter: 0.08
                });
                
                indicator.setAttribute('material', {
                    color: '#667eea',
                    opacity: 0.3,
                    transparent: true,
                    shader: 'flat'
                });
                
                indicator.setAttribute('position', `${pos.x} ${pos.y} ${pos.z}`);
                
                if (index > 0) {
                    const prevPos = predictivePattern[index - 1];
                    const line = document.createElement('a-entity');
                    
                    line.setAttribute('line', {
                        start: `${prevPos.x} ${prevPos.y} ${prevPos.z}`,
                        end: `${pos.x} ${pos.y} ${pos.z}`,
                        color: '#764ba2',
                        opacity: 0.2
                    });
                    
                    pathIndicators.appendChild(line);
                }
                
                pathIndicators.appendChild(indicator);
            });
        }

        // Create a new hotspot/target
        function createHotspot() {
            const hotspot = document.createElement('a-entity');
            
            let position;
            if (ACTIVE_CONFIG.predictiveMode && predictivePattern.length > 0) {
                const patternIndex = Math.floor(Math.random() * predictivePattern.length);
                position = predictivePattern[patternIndex];
            } else {
                const x = (Math.random() * 3) - 1.5;
                const y = (Math.random() * 2) - 0.5;
                const z = -(Math.random() * (ACTIVE_CONFIG.maxDistance - ACTIVE_CONFIG.minDistance) + ACTIVE_CONFIG.minDistance);
                position = { x, y, z };
            }
            
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const radius = isMobile ? 0.3 : 0.2;
            
            hotspot.setAttribute('position', `${position.x} ${position.y} ${position.z}`);
            hotspot.setAttribute('geometry', {
                primitive: 'sphere',
                radius: radius
            });
            hotspot.setAttribute('material', {
                shader: 'standard',
                color: '#667eea',
                emissive: '#764ba2',
                emissiveIntensity: 0.8
            });
            hotspot.setAttribute('class', 'hotspot');
            
            const ring = document.createElement('a-entity');
            ring.setAttribute('geometry', {
                primitive: 'ring',
                radiusInner: radius * 1.33,
                radiusOuter: radius * 1.67
            });
            ring.setAttribute('material', {
                color: '#FFFFFF',
                opacity: 0.8,
                transparent: true,
                side: 'double'
            });
            ring.setAttribute('visible', false);
            hotspot.appendChild(ring);
            
            hotspot.dataset.focusStartTime = 0;
            hotspot.dataset.focusQuality = 0;
            hotspot.dataset.direction = Math.random() > 0.5 ? 1 : -1;
            
            hotspot.addEventListener('mouseenter', function() {
                hotspot.dataset.focusStartTime = Date.now();
                ring.setAttribute('visible', true);
                
                ring.setAttribute('animation', {
                    property: 'geometry.thetaLength',
                    dur: ACTIVE_CONFIG.fuseTimeout,
                    from: 0,
                    to: 360,
                    easing: 'linear'
                });
            });
            
            hotspot.addEventListener('mouseleave', function() {
                ring.setAttribute('visible', false);
                ring.removeAttribute('animation');
                ring.setAttribute('geometry', {
                    primitive: 'ring',
                    radiusInner: radius * 1.33,
                    radiusOuter: radius * 1.67,
                    thetaLength: 0
                });
                
                hotspot.dataset.focusQuality = 0;
            });
            
            hotspot.addEventListener('click', function() {
                const focusDuration = Date.now() - parseInt(hotspot.dataset.focusStartTime);
                const focusQuality = Math.min(100, (focusDuration / ACTIVE_CONFIG.fuseTimeout) * 100);
                
                const enhancedQuality = (focusQuality * 0.4) + 
                                       (LEARNING_DATA.trackingAccuracy * 0.3) + 
                                       (LEARNING_DATA.anticipationScore * 0.3);
                
                LEARNING_DATA.focusQuality = enhancedQuality;
                
                if (isAudioInitialized) {
                    window.focusSound(enhancedQuality);
                    setTimeout(() => window.successSound(), 300);
                }
                
                updateLearning(enhancedQuality);
                
                this.setAttribute('animation', {
                    property: 'scale',
                    dur: 500,
                    to: '0 0 0',
                    easing: 'easeInOutQuad'
                });
                
                setTimeout(() => {
                    const index = activeHotspots.indexOf(this);
                    if (index > -1) activeHotspots.splice(index, 1);
                    
                    this.parentNode.removeChild(this);
                    setTimeout(createHotspot, ACTIVE_CONFIG.spawnDelay);
                    
                    LEARNING_DATA.targetsHit++;
                    targetsHitEl.textContent = LEARNING_DATA.targetsHit;
                    
                    scoreEl.textContent = Math.floor(LEARNING_DATA.totalLearning);
                    
                    if (LEARNING_DATA.targetsHit % 10 === 0) {
                        showMilestoneMessage();
                    }
                }, 300);
            });
            
            if (ACTIVE_CONFIG.predictiveMode) {
                hotspot.setAttribute('animation', {
                    property: 'position',
                    dur: 5000 + Math.random() * 5000,
                    easing: 'linear',
                    loop: true,
                    to: `${position.x + Math.random() - 0.5} ${position.y + Math.random() - 0.5} ${position.z}`
                });
            }
            
            hotspotsContainer.appendChild(hotspot);
            activeHotspots.push(hotspot);
            
            hotspot.tick = (time, timeDelta) => {
                if (!ACTIVE_CONFIG.predictiveMode) return;
                
                const currentPos = hotspot.getAttribute('position');
                const speed = ACTIVE_CONFIG.moveSpeed;
                const dir = parseInt(hotspot.dataset.direction);
                
                currentPos.x += Math.sin(time / 1000) * speed * dir;
                currentPos.y += Math.cos(time / 2000) * speed * dir;
                
                hotspot.setAttribute('position', currentPos);
            };
        }
        
        // Update learning model
        function updateLearning(focusQuality) {
            LEARNING_DATA.trials++;
            
            const learningFactor = focusQuality / 100;
            
            if (LEARNING_DATA.trials < 20) {
                LEARNING_DATA.fastComponent += (10 * learningFactor);
            } else {
                LEARNING_DATA.fastComponent *= (1 - LEARNING_DATA.decayRate.fast);
                LEARNING_DATA.fastComponent += (5 * learningFactor);
            }
            
            LEARNING_DATA.slowComponent *= (1 - LEARNING_DATA.decayRate.slow);
            LEARNING_DATA.slowComponent += (2 * learningFactor * Math.log(LEARNING_DATA.trials + 1));
            
            LEARNING_DATA.totalLearning = LEARNING_DATA.fastComponent + LEARNING_DATA.slowComponent;
            
            learningProgress = Math.min(100, (LEARNING_DATA.totalLearning / 200) * 100);
            progressFill.style.width = `${learningProgress}%`;
            
            updateLearningUI();
        }
        
        // Update UI with learning metrics
        function updateLearningUI() {
            focusQualityEl.textContent = `${Math.round(LEARNING_DATA.focusQuality)}%`;
            
            const learningRate = LEARNING_DATA.trials > 1 ? 
                Math.round(LEARNING_DATA.predictionEfficiency) : 0;
            learningRateEl.textContent = `${learningRate}%`;
        }
        
        // Show milestone message
        function showMilestoneMessage() {
            let message;
            
            if (LEARNING_DATA.targetsHit === 10) {
                message = "Initial learning phase complete! Your cerebellum is adapting.";
            } else if (LEARNING_DATA.targetsHit === 25) {
                message = "Fast learning engaged! Your cerebellar cortex is showing activity.";
            } else if (LEARNING_DATA.targetsHit === 50) {
                message = "Consolidation beginning! Memory transferring to cerebellar nuclei.";
            } else if (LEARNING_DATA.targetsHit === 100) {
                message = "Excellent progress! Long-term motor learning pathways forming.";
            } else {
                message = `${LEARNING_DATA.targetsHit} targets hit! Cerebellar learning is progressing.`;
            }
            
            pointMessage.textContent = message;
            pointMessage.style.display = 'block';
            pointMessage.classList.remove('fade');
            
            setTimeout(() => {
                pointMessage.classList.add('fade');
                setTimeout(() => {
                    pointMessage.style.display = 'none';
                }, 500);
            }, 5000);
        }
        
        // Update session time display
        function updateSessionTime() {
            const elapsedSec = Math.floor((Date.now() - LEARNING_DATA.sessionStartTime) / 1000);
            const minutes = Math.floor(elapsedSec / 60).toString().padStart(2, '0');
            const seconds = (elapsedSec % 60).toString().padStart(2, '0');
            sessionTimeEl.textContent = `${minutes}:${seconds}`;
        }
        
        // Update score display
        function updateScoreUI() {
            scoreEl.textContent = Math.floor(LEARNING_DATA.totalLearning);
        }
        
        // Check device orientation
        function checkOrientation() {
            if (window.innerHeight > window.innerWidth) {
                orientationMessage.style.display = 'flex';
                scene.pause();
            } else {
                orientationMessage.style.display = 'none';
                scene.play();
            }
        }
        
        // Check if gaze is within bounds
        function checkOutOfBounds() {
            const camera = document.querySelector('a-camera');
            const cameraRotation = camera.getAttribute('rotation');
            
            const yaw = cameraRotation.y;
            const pitch = cameraRotation.x;
            
            const yawLimit = 45;
            const pitchLimit = 30;
            
            if (Math.abs(yaw) > yawLimit || Math.abs(pitch) > pitchLimit) {
                outOfBoundsMessage.style.display = 'block';
                if (navigator.vibrate) {
                    navigator.vibrate(200);
                }
                
                if (LEARNING_DATA.fastComponent > 0) {
                    LEARNING_DATA.fastComponent *= 0.95;
                    updateLearningUI();
                }
            } else {
                outOfBoundsMessage.style.display = 'none';
            }
        }
        
        // Change training mode
        function changeTrainingMode() {
            const mode = trainingModeEl.value;
            ACTIVE_CONFIG = CONFIG[mode];
            
            const instructionsEl = document.querySelector('.instructions');
            
            switch(mode) {
                case 'pursuit':
                    instructionsEl.innerHTML = `
                        <h3>Pursuit Learning Exercise</h3>
                        <p>Focus on dots and track them carefully to train smooth pursuit pathways.</p>
                    `;
                    break;
                case 'prediction':
                    instructionsEl.innerHTML = `
                        <h3>Prediction Training Exercise</h3>
                        <p>Anticipate target movements before they occur to enhance predictive motor learning.</p>
                    `;
                    break;
                case 'coordination':
                    instructionsEl.innerHTML = `
                        <h3>Coordination Exercise</h3>
                        <p>Track multiple moving targets to improve complex cerebellar coordination pathways.</p>
                    `;
                    break;
            }
        }
        
        // Toggle VR Stereo Mode
        function toggleVRStereoMode() {
            isVRMode = !isVRMode;
            
            if (isVRMode) {
                scene.enterVR();
                document.body.classList.add('vr-mode');
                vrStereoToggle.textContent = 'ðŸ¥½ Exit VR Stereo Mode';
                
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                }
                
                if (screen.orientation && screen.orientation.lock) {
                    screen.orientation.lock('landscape').catch(err => {
                        console.log('Orientation lock failed:', err);
                    });
                }
            } else {
                scene.exitVR();
                document.body.classList.remove('vr-mode');
                vrStereoToggle.textContent = 'ðŸ¥½ Enable VR Stereo Mode';
                
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }
        
        // Event listeners
        window.addEventListener('resize', checkOrientation);
        window.addEventListener('orientationchange', checkOrientation);
        trainingModeEl.addEventListener('change', changeTrainingMode);
        startTrainingBtn.addEventListener('click', () => {
            // Start immediately with pursuit mode
            ACTIVE_CONFIG = CONFIG.pursuit;
            trainingModeEl.value = 'pursuit';
            changeTrainingMode();
            initSession();
            initAudio();
        });
        
        vrStereoToggle.addEventListener('click', () => {
            toggleVRStereoMode();
        });
        
        scene.addEventListener('enter-vr', () => {
            isVRMode = true;
            document.body.classList.add('vr-mode');
        });
        
        scene.addEventListener('exit-vr', () => {
            isVRMode = false;
            document.body.classList.remove('vr-mode');
        });
        
        setInterval(checkOutOfBounds, 100);
        
        scene.addEventListener('loaded', () => {
            checkOrientation();
            changeTrainingMode();
        });
    </script>
</body>
</html>
